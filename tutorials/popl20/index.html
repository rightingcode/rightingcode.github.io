---
title: 'POPL 2020 Tutorial'
layout: default
---

<div class='row'>
<div class='col-md-12'>

<center><h3>Building Program Reasoning Tools using LLVM and Z3</h3></center>
<center><h4><a href="https://popl20.sigplan.org/">POPL 2020</a> Tutorial</h4></center>
<center><h5>Monday, January 20, 2020, Time TBD</h5></center>

<center>[ <a href="#intro"><b>Introduction</b></a>
  | <a href="#tutorial"><b>Structure of Tutorial</b></a>
  | <a href="#about"><b>Learn More</b></a> ]</center>

<p>
<a name="intro">
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Introduction</b></center></font>
</td></tr>
</table>
</a>
<p>

<p>
Program reasoning has important and wide-ranging applications in programming languages,
such as type inference, static analysis, testing, verification, and synthesis. This tutorial will cover
how to build program reasoning tools using two versatile, modern, and open-source systems:
the LLVM compiler infrastructure and the Z3 constraint solver. These systems underlie
state-of-the-art tools such as Clang Static Analyzer, the KLEE symbolic execution engine, and
the SeaHorn verification framework.

<p>
This tutorial will introduce LLVM and Z3’s architecture and conduct three hands-on exercises.
They will target common applications in program reasoning that embody three distinctive
use-cases: static dataflow analysis, dynamic symbolic execution, and assertion verification.
The target audience for this tutorial is those who want hands-on experience with state-of-the-art
tools and techniques employed in program reasoning. The tutorial presumes background in C++
programming and basic logical reasoning.

<p>
<a name="tutorial">
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Structure of Tutorial</b></center></font>
</td></tr>
</table>
</a>
<p>

<p>
We will teach how to build program reasoning tools via three hands-on exercises.
Each exercise will target a different task in program reasoning that
embodies a distinctive use-case:

<ul>
<li>
Task 1: Static Dataflow Analysis. This task involves statically proving simple program
properties that are commonly targeted by dataflow analysis and type inference.</li>
<li>
Task 2: Dynamic Symbolic Execution. This task involves systematically generating program
inputs that lead to assertion violations.</li>
<li>
Task 3: Assertion Verification. This task involves statically proving assertions by generating
and solving Constrained Horn Clauses (CHC), a fragment of First Order Logic increasingly used
in verification, inference, and synthesis.</li>
</ul>

<p>
The tutorial will be structured into two parts:

<ol>
<li>
We will first introduce the prevalent systems which form the backbone of our applications. In
particular, we will cover:
<ol>
<li>LLVM, a compiler infrastructure primarily targeting the C family of languages. It is a
versatile framework that is widely used in both industry and academia. We will introduce
the architecture of LLVM as well as its language-independent intermediate
representation (IR).</li>
<li>Z3, an efficient SMT solver developed by Microsoft Research that is used for a variety of
computational problems in programming languages and beyond. We will introduce the
architecture of Z3, its capabilities, and its API. However, we will not delve into the
internals of Z3.</li>
</ol>
<li>Hands-on exercises on building three applications. Each exercise will cover a distinctive
use-case:
<ol>
<li>Static Dataflow Analysis: We will build a constraint-based static analyzer for C
programs. This will serve as an exercise in writing constraints in Datalog, and solving
them using the theory of fixed points in Z3. In doing so, we will become familiar with Z3’s
API for C program constructs.</li>
<li>Dynamic Symbolic Execution: We will implement a dynamic symbolic execution
engine that generates inputs to efficiently explore program paths in order to find inputs
that crash a C program. In this exercise, we will learn to implement an LLVM pass to
encode C program path constraints symbolically.</li>
<li>Assertion Verification: We will create an application similar to a small-scale version of
SeaHorn, a program verifier that automatically checks safety properties of C programs.
This will serve as an exercise in deriving Verification Conditions (VC) from the LLVM IR
in the form of Constrained Horn Clauses (CHC) and checking their satisfiability using Z3.</li>
</ol>
</li>
</ol>

<p>
<a name="about"/>
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Learn More</b></center></font>
</td></tr>
</table>
</a>
<p>

<p>
Bios and references

</div>
</div>
