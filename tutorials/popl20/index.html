---
title: 'POPL 2020 Tutorial'
layout: default
---

<div class='row'>
<div class='col-md-12'>

<center><h3>Building Program Reasoning Tools using LLVM and Z3</h3></center>
<center><h4><a href="https://popl20.sigplan.org/">POPL 2020</a> Tutorial</h4></center>
<center><h5>Monday, January 20, 2020, 9:00-12:30 in Room <a href="https://popl20.sigplan.org/room/POPL-2020-venue-tutorialfest-a">TutorialFest-A</a></h5></center>

<center>[ <a href="#intro"><b>Introduction</b></a>
  | <a href="#tutorial"><b>Structure of Tutorial</b></a>
  | <a href="#started"><b>Getting Started</b></a>
  | <a href="#about"><b>Learn More</b></a> ]</center>

<p>
<a name="intro">
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Introduction</b></center></font>
</td></tr>
</table>
</a>
<p>

<p>
Program reasoning has important and wide-ranging applications in programming languages,
such as type inference, static analysis, testing, verification, and synthesis. This tutorial will cover
how to build program reasoning tools using two versatile, modern, and open-source systems:
the LLVM compiler infrastructure and the Z3 constraint solver. These systems underlie
state-of-the-art tools such as Clang Static Analyzer, the KLEE symbolic execution engine, and
the SeaHorn verification framework.

<p>
This tutorial will introduce LLVM and Z3’s architecture and conduct three hands-on exercises.
The exercises will target common applications in program reasoning that embody three distinctive
use-cases: static dataflow analysis, dynamic symbolic execution, and assertion verification.
The target audience for this tutorial is those who want hands-on experience with state-of-the-art
tools and techniques employed in program reasoning. The tutorial presumes background in C++
programming and basic logical reasoning.

<p>
<a name="tutorial">
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Structure of Tutorial</b></center></font>
</td></tr>
</table>
</a>
<p>


<p>
We will teach how to build program reasoning tools via three hands-on exercises. The tutorial will be structured into two parts.

<h5>Part I: Introduction to LLVM and Z3.</h5> 

<p>
We will first introduce the systems which form the backbone of our applications. In
particular, we will cover:
<ol>
<li>LLVM, a compiler infrastructure primarily targeting the C family of languages. It is a
versatile framework that is widely used in both industry and academia. We will introduce
the architecture of LLVM as well as its language-independent intermediate
representation (IR).<br></li>
<li>Z3, an efficient SMT solver developed by Microsoft Research that is used for a variety of
computational problems in programming languages and beyond. We will introduce the
architecture of Z3, its capabilities, and its API. However, we will not delve into the
internals of Z3.</li>
</ol>

<h5>Part II: Building Three Applications.</h5>

<p>
We will then conduct hands-on exercises on building three applications. Each exercise will cover 
a distinctive use-case: dataflow analysis, symbolic execution, and verification. We discuss each in turn.

<p>
<b>1. Static Dataflow Analysis.</b>
We will build a constraint-based static analyzer for C programs. This will serve as an exercise in writing constraints in Datalog, and solving them using the theory of fixed points in Z3. In doing so, we will become familiar with Z3’s API for C program constructs.

<p>
<b>2. Dynamic Symbolic Execution.</b>
We will implement a dynamic symbolic execution engine that generates inputs to efficiently explore program paths in order to find inputs that crash a C program. In this exercise, we will learn to implement an LLVM pass to encode C program path constraints symbolically.

<p>
<b>3. Assertion Verification.</b>
We will create an application similar to a small-scale version of SeaHorn, a program verifier that automatically checks safety properties of C programs. This will serve as an exercise in deriving Verification Conditions (VC) from the LLVM IR in the form of Constrained Horn Clauses (CHC) and checking their satisfiability using Z3.

<p>
<a name="about"/>
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Getting Started</b></center></font>
</td></tr>
</table>
</a>
<p>

<p>

We provide a docker image for the tutorial that contains skeleton code for each of the three hands-on exercises. Follow the <a href=https://docs.google.com/document/d/1eljJKiIjI0n8MMmOQ76qBMBSOHakFMc4kF16iiAjBec/edit>step-by-step guide</a> that details how to set up and run the tutorial docker which is <a href="https://hub.docker.com/repository/docker/petablox/popl2020-tutorial">hosted on dockerhub</a>. The following is a quick-start guide to get you up and running:

<p>
To download the docker image:
<p>
<code>
docker pull petablox/popl2020-tutorial
</code>

<p>
To start a docker container:
<p>
<code>
docker run -it --name popl2020 petablox/popl2020-tutorial
</code>

<p>
Solutions to each of the exercises will be uploaded and distributed during the tutorial.
<p>



<p>
<a name="about"/>
<table border=0 cellpadding=4 width="100%">
<tr><td width="100%" bgcolor="#ccccff">
<font face="Cambria"><center><b>Learn More</b></center></font>
</td></tr>
</table>
</a>
<p>

<h4>About the Presenters</h4>

  <p><a href="https://www.cis.upenn.edu/~mhnaik/">Mayur Naik</a> is a professor of computer science at the University of Pennsylvania. His research interests span the areas of program analysis, constraint solving, and machine learning for programming. He holds a Ph.D. in Computer Science from Stanford University. Earlier, he was a researcher at Intel Labs and a professor in the College of Computing at Georgia Tech.</p>

  <p><a href="https://www.seas.upenn.edu/~edinella/">Elizabeth Dinella</a> is a 2nd year PhD student at the University of Pennsylvania advised by Professor Mayur Naik. She received her B.S. in computer science from Rensselaer Polytechnic Institute in 2018. Her research interests lie in the fields of software engineering and programming languages. In particular, she is excited about applying machine learning techniques to solve traditional program analysis problems.</p>

  <p><a href="https://www.seas.upenn.edu/~pardisp/">Pardis Pashakhanloo</a> is a 3rd year PhD student at the University of Pennsylvania co-advised by Professor Mayur Naik and Professor Boon Thau Loo. She received her B.Sc. in Software Engineering from Sharif University of Technology in 2017. At the intersection of program analysis, machine learning, and software security, Pardis seeks to develop methodologies and frameworks to eliminate security vulnerabilities by reducing system-wide complexity.</p>

  <p><a href="https://anthonycanino1.github.io">Anthony Canino</a> is a Postdoctoral Researcher at the University of Pennsylvania working with Professor Mayur Naik. His current work focuses on debloating large software systems for increased performance and security. He previously focused on on using programming languages to help programmers build energy efficient software. Moving forward, he aims to strengthen the support that programming languages and models can provide in performance-critical systems, e.g., unmanned aerial vehicles and mobile devices.</p> 

<h4>Resources</h4>

<ul>
  <li><a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference</a></li>
  <li><a href="https://github.com/Z3Prover/z3">Z3 Theorem Prover</a></li>
</ul>

<h4>References</h4>

The below references describe tools, systems, and frameworks that we use in or have influenced our tutorial.

<table cellpadding="5">
  
<a name="cgo04"/>
<tr><td>[CGO '04]</td><td>Chris Lattner and Vikram Adve.
<b><a href="https://llvm.org/pubs/2003-09-30-LifelongOptimizationTR.pdf">LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation</a></b>.</td>
</tr> 
  
<a name="osdi08"/>
<tr><td>[OSDI '08]</td><td>Cristian Cadar, Daniel Dunbar, and Dawson Engler.
<b><a href="http://www.doc.ic.ac.uk/~cristic/papers/klee-osdi-08.pdf">KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs</a></b>.</td>
</tr>


<a name="tacas08"/>
<tr><td width="110">[TACAS '08]</td><td>Leonardo de Moura and Nikolaj Bjørner
<b><a href="https://link.springer.com/content/pdf/10.1007%2F978-3-540-78800-3_24.pdf">Z3: An Efficient SMT Solver</a></b>.</td>
</tr>

<a name="tacas08"/>
<tr><td>[CAV '15]</td><td>Arie Gurfinkel, Temesghen Kahsai, Anvesh Komuravelli, and Jorge A. Navas.
<b><a href="https://jorgenavas.github.io/papers/seahorn-cav15.pdf">The SeaHorn Verification Framework</a></b>.</td>
</tr>


</table>

</div>
</div>
